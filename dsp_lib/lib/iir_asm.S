//-----------------------------------------------------------------------------
//created by Miroslaw Folejewski
//from 2010.09 to 2010.10
//-----------------------------------------------------------------------------
// Thumb-2 instructions are only supported in unified syntax mode
.syntax unified
//-----------------------------------------------------------------------------
.section ".text"
//-----------------------------------------------------------------------------
// Declare as thumb function. Otherwise it will not be linked correctly
.thumb_func
//=============================================================================
	.macro smul_32_64 	p1,p2,p3
//=============================================================================
// multiplication: 32 x 64 bit -> 96 bit
// [r4, r5, r6] - acc, result
// r7 = 1st element
// [r8 (L), r9 (H)] - 2nd element
// r10 - flags, temp register
//-----------------------------------------------------------------------------
//reset result
	eor r6, r6
	eor r10, r10
//-----------------------------------------------------------------------------
// 1st element < 0?
	tst r7, #0x80000000
	beq \p1
// add negative sign
	add r10, #1
// calculate 1st negative element
	neg r7, r7
\p1:
// 2nd element < 0?
	tst r9, #0x80000000
	beq \p2
// add negative sign
	add r10, #1
// calculate 2nd negative element
	negs r8, r8
	mvn r9, r9
	adcs r9, #0
\p2:
// multiply 32 x 64 bit
	umull r4, r5, r7, r8
	umlal r5, r6, r7, r9
//-----------------------------------------------------------------------------
// flags = 1?
	subs r10, #1
	bne \p3
// calculate egative result
	negs r4, r4
	mvn r5, r5
	mvn r6, r6
	adcs r5, #0
	adcs r6, #0
\p3:
//-----------------------------------------------------------------------------
	.endm
//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// Declare as thumb function. Otherwise it will not be linked correctly
.thumb_func
//=============================================================================
	.macro asr_94_64
//=============================================================================
// rigth arithmetic shift by 30 bits
// [r4 (L), r5, r6 (H)] - 94 bit input
// [r4 (L), r5 (H)] - 64 bit output
// 94 bits >> 30 = 64 bits
	bfi.w r4, r5, #0, #30
	bfi.w r5, r6, #0, #30
	ror r4, #30
	ror r5, #30
//-----------------------------------------------------------------------------
	.endm
//-----------------------------------------------------------------------------



//=============================================================================
// IIR biquad filter, 2nd-order - direct form II - low-pass filter
//-----------------------------------------------------------------------------
// r0 - tab1 pointer (coefficients) - 32 bit - coeff[0] = gain, coeff[1] = B1, coeff[2] = B2
// r1 - tab2 pointer (buffer) - 64 bit - buffer[0], buffer[1], buffer[2]
// r2 - tab3 pointer (input, output) - 32 bit - input, output
// r3 - number of function iterations (higher-order iir filter)

// r0 - not updated after loop ending
// r1 - increased by 6 addresses after the loop ending
// r2 - increased by 1 address after the loop ending
// r3 - decremented after the loop ending
//=============================================================================
// Declare as thumb function. Otherwise it will not be linked correctly
.thumb_func
//-----------------------------------------------------------------------------
// Export the symbol so linker can see this
.global iir_lpf
//-----------------------------------------------------------------------------
iir_lpf:
//-----------------------------------------------------------------------------
// no jumps to functions (only macro using)
	push {lr}
	push {r4, r5, r6, r7, r8, r9, sl, fp, lr}
//-----------------------------------------------------------------------------
iir_lpf_loop:
//-----------------------------------------------------------------------------
// r7 = coeff[2], r0 = r0
	ldr r7, [r0, #8]
//-----------------------------------------------------------------------------
// [r8, r9] = buffer[1], r1 = r1
	ldrd.w r8, r9, [r1, #8]
//-----------------------------------------------------------------------------
// buffer[2] = buffer[1], r1 = r1
	strd.w r8, r9, [r1, #16]
//-----------------------------------------------------------------------------
// coeff[2] * buff[2]
	smul_32_64 	llpf1,llpf2,llpf3
//-----------------------------------------------------------------------------
// save result on the stack
	push {r4-r6}
//-----------------------------------------------------------------------------
// r7 = coeff[1], r0 = r0
	ldr r7, [r0, #4]
//-----------------------------------------------------------------------------
// [r8, r9] = buffer[0], r1 = r1
	ldrd.w r8, r9, [r1]
//-----------------------------------------------------------------------------
// buffer[1] = buffer[0], r1 = r1
	strd.w r8, r9, [r1, #8]
//-----------------------------------------------------------------------------
// coeff[1] * buff[1]
	smul_32_64 llpf4,llpf5,llpf6
//-----------------------------------------------------------------------------
// r7 = input, r2 = r2
	ldr r7, [r2]
// [r7, r8] = r7 << 30
	asr r9, r7, #31
	asr r8, r7, #2
	lsl r7, r7, #28
//-----------------------------------------------------------------------------
// adding result
	adds r4, r7
	adcs r5, r8
	adcs r6, r9
	pop {r7-r9}
	adds r4, r7
	adcs r5, r8
	adcs r6, r9
//-----------------------------------------------------------------------------
// [r4, r5, r6] >> 30 = [r4, r5]
	asr_94_64
//-----------------------------------------------------------------------------
// buffer[0] = sum, r1 = r1 + 24
	strd.w r4, r5, [r1], #24
//-----------------------------------------------------------------------------
// LPF (low-pass filter) version => A0 = +1, A1 = +2, A2 = +1
//-----------------------------------------------------------------------------
// [r6, r7] = buffer[2], r1 = r1
	ldrd.w r6, r7, [r1, #-8]
// [r4, r5] = buffer[0] + buffer[2]
	adds r4, r6
	adcs r5, r7
//-----------------------------------------------------------------------------
// [r6, r7] = buffer[1], r1 = r1
	ldrd.w r6, r7, [r1, #-16]
// [r8, r9] = [r4, r5] + 2 * buffer[1]
	adds r4, r6
	adcs r5, r7
	adds r8, r4, r6
	adcs r9, r5, r7
//-----------------------------------------------------------------------------
// r7 = coeff[0], r0 = r0
	ldr r7, [r0]
//-----------------------------------------------------------------------------
// coeff[0] * buff[1]
	smul_32_64 llpf7,llpf8,llpf9
//-----------------------------------------------------------------------------
// [r4, r5, r6] >> 30 = [r4, r5]
	asr_94_64
//-----------------------------------------------------------------------------
// r5 = output, r2 = r2 + 4
	str r4, [r2], #4
//-----------------------------------------------------------------------------
// loop (higher-order iir filter) - can be omitted by comment
	subs r3, #1
	bne iir_lpf_loop
//-----------------------------------------------------------------------------
	pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}
// no jumps to functions (only macro using)
	pop {pc}
//	bx lr
//-----------------------------------------------------------------------------



//=============================================================================
// IIR biquad filter, 2nd-order - direct form II - high-pass filter
//-----------------------------------------------------------------------------
// r0 - tab1 pointer (coefficients) - 32 bit - coeff[0] = gain, coeff[1] = B1, coeff[2] = B2
// r1 - tab2 pointer (buffer) - 64 bit - buffer[0], buffer[1], buffer[2]
// r2 - tab3 pointer (input, output) - 32 bit - input, output
// r3 - number of function iterations (higher-order iir filter)

// r0 - not updated after loop ending
// r1 - increased by 6 addresses after the loop ending
// r2 - increased by 1 address after the loop ending
// r3 - decremented after the loop ending
//=============================================================================
// Declare as thumb function. Otherwise it will not be linked correctly
.thumb_func
//-----------------------------------------------------------------------------
// Export the symbol so linker can see this
.global iir_hpf
//-----------------------------------------------------------------------------
iir_hpf:
//-----------------------------------------------------------------------------
// no jumps to functions (only macro using)
	push {lr}
	push {r4, r5, r6, r7, r8, r9, sl, fp, lr}
//-----------------------------------------------------------------------------
iir_hpf_loop:
//-----------------------------------------------------------------------------
// r7 = coeff[2], r0 = r0
	ldr r7, [r0, #8]
//-----------------------------------------------------------------------------
// [r8, r9] = buffer[1], r1 = r1
	ldrd.w r8, r9, [r1, #8]
//-----------------------------------------------------------------------------
// buffer[2] = buffer[1], r1 = r1
	strd.w r8, r9, [r1, #16]
//-----------------------------------------------------------------------------
// coeff[2] * buff[2]
	smul_32_64 lhpf1,lhpf2,lhpf3
//-----------------------------------------------------------------------------
// save result on the stack
	push {r4-r6}
//-----------------------------------------------------------------------------
// r7 = coeff[1], r0 = r0
	ldr r7, [r0, #4]
//-----------------------------------------------------------------------------
// [r8, r9] = buffer[0], r1 = r1
	ldrd.w r8, r9, [r1]
//-----------------------------------------------------------------------------
// buffer[1] = buffer[0], r1 = r1
	strd.w r8, r9, [r1, #8]
//-----------------------------------------------------------------------------
// coeff[1] * buff[1]
	smul_32_64	lhpf4,lhpf5,lhpf6
//-----------------------------------------------------------------------------
// r7 = coeff[0], r0 = r0
	ldr r7, [r0]
//-----------------------------------------------------------------------------
// r8 = input, r2 = r2
	ldr r8, [r2]
//-----------------------------------------------------------------------------
// coeff[0] * input
	smull r7, r8, r7, r8
	asr r9, r8, #31
//-----------------------------------------------------------------------------
// adding result
	adds r4, r7
	adcs r5, r8
	adcs r6, r9
	pop {r7-r9}
	adds r4, r7
	adcs r5, r8
	adcs r6, r9
//-----------------------------------------------------------------------------
// [r4, r5, r6] >> 30 = [r4, r5]
	asr_94_64
//-----------------------------------------------------------------------------
// buffer[0] = sum, r1 = r1 + 24
	strd.w r4, r5, [r1], #24
//-----------------------------------------------------------------------------
// HPF (high-pass filter) version => A0 = +1, A1 = -2, A2 = +1
//-----------------------------------------------------------------------------
// [r6, r7] = buffer[2], r1 = r1
// omit r7 loading
//	ldrd.w r6, r7, [r1, #-8]
// load r6 only
	ldr r6, [r1, #-8]
// [r4, r5] = buffer[0] + buffer[2]
	adds r4, r6
// omit that instruction
//	adcs r5, r7
//-----------------------------------------------------------------------------
// [r6, r7] = buffer[1], r1 = r1
// omit r7 loading
//	ldrd.w r6, r7, [r1, #-16]
// load r6 only
	ldr r6, [r1, #-16]
// [r6, r7] -= r6, r7
	negs r6, r6
// omit that instruction
//	mvn r7, r7
// omit that instruction
//	adcs r7, #0
// [r4, r5] -= 2 * buffer[1]
	adds r4, r6
// omit that instruction
//	adcs r5, r7
	adds r4, r6
// omit that instruction
//	adcs r5, r7
//-----------------------------------------------------------------------------
// r4 = output, r2 = r2 + 4
	str r4, [r2], #4
//-----------------------------------------------------------------------------
// loop (higher-order iir filter) - can be omitted by comment
//	subs r3, #1
//	bne iir_hpf_loop
//-----------------------------------------------------------------------------
	pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}
// no jumps to functions (only macro using)
	pop {pc}
//	bx lr
//-----------------------------------------------------------------------------


//=============================================================================
// DC offset adding
//-----------------------------------------------------------------------------
// r0 - tab1 pointer (offset) - 32 bit - offset
// r1 - tab2 pointer (input, output) - 32 bit - input, output
// r2 - = 0 => 16 bit saturation, <> 0 => 24 bit saturation

// r0 - not updated after loop ending
// r1 - increased by 1 address after the loop ending
// r2 - not updated after loop ending
//=============================================================================
// Declare as thumb function. Otherwise it will not be linked correctly
.thumb_func
//-----------------------------------------------------------------------------
// Export the symbol so linker can see this
.global set_offset
//-----------------------------------------------------------------------------
set_offset:
//-----------------------------------------------------------------------------
// no jumps to functions (only macro using)
	push {lr}
	push {r4-r6}
//-----------------------------------------------------------------------------
// r4 = offset L, r0 = r0
	ldr r4, [r0, #2]
	bfi.w r5, r4, #0, #8
// r4 = offset M, r0 = r0
	ldr r4, [r0, #1]
	bfi.w r5, r4, #8, #8
// r4 = offset H, r0 = r0
	ldr r4, [r0, #0]
	bfi.w r5, r4, #16, #8
// r5 = extend sign
	sbfx.w r5, r5, #0, #24
//-----------------------------------------------------------------------------
// r4 = input, r1 = r1
	ldr r4, [r1]
//-----------------------------------------------------------------------------
// add offset
	add r4, r4, r5
//-----------------------------------------------------------------------------
//result saturation - 16/24 bits
	tst r2, r2
	beq sat_24bit
	ssat.w r4, #16, r4
	b sat_done
sat_24bit:
	ssat.w r4, #24, r4
sat_done:
//-----------------------------------------------------------------------------
// r4 = output (input), r1 = r1 + 4
	str r4, [r1], #4
//-----------------------------------------------------------------------------
	pop {r4-r6}
// no jumps to functions (only macro using)
	pop {pc}
	bx lr
//-----------------------------------------------------------------------------


//=============================================================================
// adjustable gain amplifier
//-----------------------------------------------------------------------------
// r0 - tab1 pointer (coefficients) - 32 bit - gain
// r1 - tab2 pointer (input, output) - 32 bit - input, output
// r2 - = 0 => 16 bit saturation, <> 0 => 24 bit saturation
//=============================================================================
// Declare as thumb function. Otherwise it will not be linked correctly
.thumb_func
//-----------------------------------------------------------------------------
// Export the symbol so linker can see this
.global adj_gain
//-----------------------------------------------------------------------------
adj_gain:
//-----------------------------------------------------------------------------
// no jumps to functions (only macro using)
	push {lr}
	push {r4-r6}
//-----------------------------------------------------------------------------
// r4 = gain, r0 = r0
	ldr r4, [r0]
//-----------------------------------------------------------------------------
// r5 = input, r1 = r1
	ldr r5, [r1]
//-----------------------------------------------------------------------------
// gain * input
	smull r4, r5, r4, r5
//-----------------------------------------------------------------------------
//result saturation - 16/24 bits
	tst r2, r2
	beq gain_sat_24bit
	ssat.w r4, #16, r4
	b gain_sat_done
gain_sat_24bit:
	ssat.w r4, #24, r4
gain_sat_done:
//-----------------------------------------------------------------------------
// r4 = output (input), r1 = r1
	str r4, [r1]
//-----------------------------------------------------------------------------
	pop {r4-r6}
// no jumps to functions (only macro using)
	pop {pc}
	bx lr
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
	.end
//-----------------------------------------------------------------------------
